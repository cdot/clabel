#!/usr/bin/perl -w

# C-Label designer for Brother 1230PC label printer
# Crawford Currie (C) 2015 http://c-dot.co.uk
# Based on B-Label (C) 2012 A. Sovijärvi (ari@sovijarvi.fi)
# Distributed under the Perl Artistic License.

use strict;
use warnings;

# Before attempting to upgrade to Gtk3, make sure Pango::Cairo perl bindings
# are available and work. They weren't on 8/10/17
use Gtk2 -init;
use Cairo ();
use GD ();
use Getopt::Long ();
use Data::Dumper ();
use File::Basename ();
use Net::CUPS ();
use File::Temp ();
use Encode ();
use Data::Dumper;

use constant GLADE_FILE => File::Basename::dirname(__FILE__).'/clabel.glade';
use constant SETTINGS => "$ENV{HOME}/.config/clabel";

# Don't use constant because it doesn't work in classes
our $BASE = [ 'printer', 'font', 'tape' ];
our $PER_LABEL = [
    'text', 'bold', 'italic', 'underline', 'tt',
    'sub', 'sup', 'halign', 'hmargin', 'inverse', 'delete_label'
    ];
our $BLACK = [ 0, 0, 0 ];
our $WHITE = [ 255, 255, 255 ];
our $RED   = [ 0, 0, 255 ];
our $INTER_LABEL_GAP = 4; # pixels
our $HIGHLIGHT_BORDER = 2; # highlight border

# Methods for saving and loading config items
our $CONFIG = {
    default => {
        save => sub { $_[0]->get_active() },
        load => sub { $_[0]->set_active($_[1]) },
    },
    inverse => {
        save => sub { $_[0]->get_active() ? 1 : 0 }
    },
    hmargin => {
        save => sub { $_[0]->get_value() }
    },
    font => {
        save => sub { $_[0]->get_font_name() },
        load => sub { $_[0]->set_font_name($_[1]) },
    }
};

our $device;
our $ui;
# List of Labels objects
our @labels;
# Index of current labe;
our $current_label = -1;
our $default_fontdesc; # a font descriptor

sub report {   
    print join(
        '',
        map {
          ref($_)
            ? ( $_->can('stringify')
                ? $_->stringify()
                : ( $_->can('to_string')
                    ? $_->to_string()
                    : Data::Dumper->Dump([$_])))
            :  $_
       } @_) . "\n";
}

# See
# http://etc.nkadesign.com/uploads/Printers/95CRRASE.pdf
# for printer protocol
# Test with https://9cb21392cee7550e9d82f3f871ce806316582628.googledrive.com/host/0B7Vet6dn3-Gwd3BKVmwzR0pjU0E/index.html
sub prepare_image_for_printer {
    my ($pb) = @_;

    die "No pixbuf" unless ($pb);
    my $pngdata = $pb->save_to_buffer("png");
    my $gdimage = GD::Image->newFromPngData($pngdata);

    # we turn it 90 degrees before anything else to orient to the printer
    $gdimage = $gdimage->copyRotate90();

    my @pixel = ();
    my ($width, $height) = $gdimage->getBounds();

    #my $b = $gdimage->colorAllocate(0, 0, 0);
    #$gdimage->line(0, 0, $width, $height, $b);
    #$gdimage->line(0, $height, $width, 0, $b);

    my $output = ""
        . "\e@"         # Initialise Clear print buffer
        . "\eiS"        # Send printer status
        . "\eiR".chr(1) # set raster transfer mode 1
        ;

    # PT1230PC has 64 pins, and for some inexplicable reason needs
    # 32 bits offset for 12mm tape. If we are printing narrower
    # tape, the offset is scaled proportionally
    my $offset = 32 + (64 - $width) / 2;

    #print STDERR "Offset $offset Width $width\n";
    for (my $y = $height - 1; $y >= 0 ; $y--) {
        my $raster = '';

        # Pack 8 pixels into an 8 bit byte
        my $x;
        my $byte = 0;
        my $bit = 0;
        for ($x = 0; $x < $offset; $x++) {
            if (++$bit == 8) {
                $raster .= "\0";
                $bit = 0;
            }
        }
        for ($x = 0; $x < $width; $x++) {
            my $tmpcolor = $gdimage->getPixel($x, $y);
            my ($r, $g, $b) = $gdimage->rgb($tmpcolor);
            # it's B/W, so we only need to compare one value
            # SMELL: use alpha?
            $byte |= (0x80 >> $bit) if $r < 150;
            if (++$bit == 8) {
                $raster .= chr($byte);
                $byte = 0;
                $bit = 0;
            }
        }
        $raster .= chr($byte) if $bit;
        if ($raster =~ /[^\x00]/) {
            $output .= "G"
                . chr(length($raster) % 256)
                . chr(int(length($raster) / 256))
                . $raster;
            #print STDERR "Raster ".length($raster)."\n";
        } else {
            $output .= 'Z';
            #print STDERR "Zeros\n";
        }
    }
    $output .= "\x1A"; # SUB eject print buffer data
#    $output .= "\x0C"; # print buffer data
    print length($output)." bytes\n";
    return $output;
}

# -- GUI elements -----------------------------------------------------------
sub kill_editorwindow {
    Gtk2->main_quit();
    save_config();
}

sub fill_printer_list {
    my $found = 0;
    foreach my $p (Net::CUPS->getDestinations()) {
        $ui->get_object('printer')->remove_text(0) unless $found;
        $found = 1;
        $ui->get_object('printer')->append_text($p->getName());
    }
}

# Print out the result with more or less ghetto way of passing data
# from pixbuf to GD.
sub print_clicked_cb {
    my $pb = render_labels(0);

    my ($fh, $fn);

    if ($device) {
        sysopen($fh, $device, Fcntl::O_RDWR) || die $!;
        print STDERR "Printing to $device\n";
    } else {
        open($fh, '>', $fn = '/tmp/cpanel') || die $!;
    }

    binmode($fh);

    print $fh prepare_image_for_printer($pb);

    if ($device) {
        local $/ = undef;
        my $reply = ' ' x 256;
        my $rb = sysread($fh, $reply, 256);
        print "Response $rb "
            . join(' ', map {
                $_ =~ /[ -~]/ ? $_ : sprintf("%02x", ord($_))
                   } split(//, $reply))
            . "\n"; 
        close($fh);
    } else {
        close($fh);
        my $pn = $ui->get_object('printer')->get_active_text();
        foreach my $printer (Net::CUPS->getDestinations()) {
            if ($pn eq $printer->getName()) {
                $printer->printFile($fn, 'label');
                return;
            }
        }
    }
}

sub label_at {
    my $x = shift;

    my $n = 0;
    foreach my $label (@labels) {
        if ($label->{image_offset} > $x) {
            return $n - 1;
        }
        $n++;
    }
    return scalar(@labels) - 1;
}

{
    package Label;

    sub new {
        my $this = bless({
            # Text of the label
            text => "",
            # Boolean, true to invert the label
            inverse => 0,
            # int, px horz margin between text and edge
            hmargin => 2,
            # Horizontal alignment of label - left = 0, centre = 1, right = 2
            halign => 1,
            # Offset of the label in the all-labels picture
            image_offset => 0
                         }, shift);
        return $this;
    }

    sub from_ui {
        my $this = shift;

        # Get the text from the text widget
        my $buffer = $ui->get_object('text')->get_buffer();
        my ($start, $end) = $buffer->get_bounds();
        $this->{text} = $buffer->get_text($start, $end, 1);
        #print STDERR "UI get '$this->{text}'\n";
        $this->{inverse} = $ui->get_object('inverse')->get_active();
        $this->{halign} = $ui->get_object('halign')->get_active();
        $this->{hmargin} = $ui->get_object('hmargin')->get_value();
    }

    sub to_ui {
        my $this = shift;
        my $buffer = $ui->get_object('text')->get_buffer();
        # SMELL: only way I could get GTK to work
        my $s = $this->{text};
        $s = Encode::decode(
            'utf8', Encode::encode(
                'utf8', $s,Encode::FB_CROAK),
            Encode::FB_CROAK);
        #print STDERR "UI set '$this->{text}'\n";
        $buffer->set_text($s);#this->{text});
        $ui->get_object('inverse')->set_active($this->{inverse});
        $ui->get_object('halign')->set_active($this->{halign});
        $ui->get_object('hmargin')->set_value($this->{hmargin});
    }

    # Lay out the label in an image. The image is laid out on a surface
    # in a box that is a maximum of $tape_width pixels high, surounded
    # by a highlight region.
    sub render {
        my ($this, $tape_width) = @_;

        $this->{surface} = undef;

        # Create a 0-sized surface just for measuring text
        my $surface = Cairo::ImageSurface->create('argb32', 0, 0);
        my $context = Cairo::Context->create($surface);
        my $layout;
        
        # A label may be made up of multiple lines. Layout each line
        # separately. Note we'll get an error if a <span> is broken
        # across lines, but this is the easiest way to lay out lines
        # in the middle of their available space. Each line is laid
        # out in the minimum required space.
        my @lines;
        my $total_height = 0; # total height of the label.
        my $max_width = 10;  # width of the widest line in the label.
        foreach my $line (split(/\n/, $this->{text})) {
            $layout = Pango::Cairo::create_layout($context);
            # Set the default font
            $layout->set_font_description($default_fontdesc);
            $layout->set_markup($line);
            my ($xsize, $ysize) = $layout->get_pixel_size();
            main::report "'", $line, "' is ", $xsize, ' X ', $ysize;
            $total_height += $ysize;
            $xsize += 2 * $this->{hmargin};
            $max_width = $xsize if $xsize > $max_width;
            push(@lines, {
                width  => $xsize,
                height => $ysize,
                text => $line
                 });
        }
        
        if ($max_width == 0) {
            #print STDERR "Zero width label $this->{text}\n";
            return;
        }

        # Remember how wide the label (not the surface) is
        $this->{pxwidth} = $max_width;
        $this->{mmwidth} = $max_width * (12 / 64);
        
        #print STDERR "Label requires $max_width X $total_height\n";

        # Space above, below and between lines, and on left/right
        my $space = ($tape_width - $total_height) / (scalar(@lines) + 1);

        # Create the rendering surface.
        # 32 bits per pixel is complete overkill!
        my $surfw = $max_width + 2 * $HIGHLIGHT_BORDER;
        my $surfh = $tape_width + 2 * $HIGHLIGHT_BORDER;
        $surface = Cairo::ImageSurface->create(
            'argb32', $surfw, $surfh);

        $context      = Cairo::Context->create($surface);

        # Paint the highlight border
        $context->set_source_rgb(@$RED);
        $context->rectangle(0, 0, $surfw, $surfh);
        $context->fill();

        # Paint the label background
        $context->set_source_rgb(@{$this->{inverse} ? $BLACK : $WHITE});
        $context->rectangle($HIGHLIGHT_BORDER, $HIGHLIGHT_BORDER, $max_width, $tape_width);
        $context->fill();

        # Paint the label
        $context->set_source_rgb(@{$this->{inverse} ? $WHITE : $BLACK});

        # Alignment within the available space
        my $yoff = $HIGHLIGHT_BORDER + $space;
        foreach my $line (@lines) {
            my $xoff = $HIGHLIGHT_BORDER;
            
            if ($this->{halign} == 1) { # left
                $xoff += $this->{hmargin};
            } elsif ($this->{halign} == 1) { # centre
                $xoff += ($max_width - $line->{width}) / 2;
            } elsif ($this->{halign} == 2) { # right
                $xoff += $max_width - $this->{hmargin} - $line->{width};
            }
            $context->move_to($xoff, $yoff);
            $layout = Pango::Cairo::create_layout($context);
            # Set the default font
            $layout->set_font_description($default_fontdesc);
            $layout->set_markup($line->{text});
            Pango::Cairo::show_layout($context, $layout);
            $yoff += $line->{height} + $space;
        }
        $context->show_page();

        # Remember the rendering surface
        $this->{surface} = $surface;
    }
}

# $highlight_selected should be false when rendering the print buffer
sub render_labels {
    my $highlight_selected = shift;

    return undef unless scalar(@labels);

    # P-touch 1230PC 12mm tape is 64 pixels wide. Narrower tapes use
    # only the centre print heads.
    my $tape_width = $ui->get_object('tape')->get_active_text() || '12mm';
    $tape_width =~ s/mm$//;
    $tape_width  = $tape_width * (64/12);

    my $superwidth = 0;
    my $superheight = 0;

    foreach my $label (@labels) {
        #print STDERR "Render $label->{text}\n";
        $label->render($tape_width);
        next unless $label->{surface};
        $superwidth += $label->{surface}->get_width();
        my $h = $label->{surface}->get_height();
        $superheight = $h if $h > $superheight;
        $superwidth += $INTER_LABEL_GAP;
    }
    return unless $superwidth;

    $superwidth -= $INTER_LABEL_GAP;

    # if there is no highlight, get rid of the extra space
    # allocated for the highlight border
    unless ($highlight_selected) {
        $superheight -= 2 * $HIGHLIGHT_BORDER;
        $superwidth -= scalar(@labels) * 2 * $HIGHLIGHT_BORDER;
    }

    # Create a super-pixbuf with all the labels.
    #print STDERR "Supersize $superwidth X $superheight\n";
    my $pixbuf = Gtk2::Gdk::Pixbuf->new(
        'rgb', 1, 8, $superwidth, $superheight);

    # Fill background with a funny colour so we can see
    # inter-label cut lines
    $pixbuf->fill(0xCAFEBABE);

    my $xoff = 0;
    for (my $i = 0; $i < scalar(@labels); $i++) {
        my $label = $labels[$i];
        next unless $label->{surface};

        my $highlight = ($highlight_selected && $i == $current_label);

        # Contrary to the Cairo doc, 'rgb24' format has an alpha channel
        my $lpb = Gtk2::Gdk::Pixbuf->new_from_data(
            $label->{surface}->get_data(),
            'rgb', 1, 8,
            $label->{surface}->get_width(),
            $label->{surface}->get_height(),
            $label->{surface}->get_stride());

        #print STDERR "Layout ".$lpb->get_width()." X ".$lpb->get_height()
        #    ." label $i at $xoff\n";
        $label->{image_offset} = $xoff;
        if ($highlight) {
            # Slap out the whole area, highlight included
            $lpb->copy_area(0, 0, $lpb->get_width(), $lpb->get_height(),
                            $pixbuf, $xoff, 0);
            $xoff += $lpb->get_width();
        } elsif ($highlight_selected) {
            # Whack out just the middle, allowing for the highlight
            $lpb->copy_area(
                $HIGHLIGHT_BORDER, $HIGHLIGHT_BORDER,
                $lpb->get_width() - 2 * $HIGHLIGHT_BORDER,
                $lpb->get_height() - 2 * $HIGHLIGHT_BORDER,
                $pixbuf, $xoff + $HIGHLIGHT_BORDER, $HIGHLIGHT_BORDER);
            $xoff += $lpb->get_width();
        } else {
            # Stick out the middle, with no highlight
            $lpb->copy_area(
                $HIGHLIGHT_BORDER, $HIGHLIGHT_BORDER,
                $lpb->get_width() - 2 * $HIGHLIGHT_BORDER,
                $lpb->get_height() - 2 * $HIGHLIGHT_BORDER,
                $pixbuf, $xoff, 0);
            $xoff += $lpb->get_width() - 2 * $HIGHLIGHT_BORDER;
        }
        $xoff += $INTER_LABEL_GAP;
    }
    return $pixbuf;
}

sub attribute_clicked {
    my $attr = shift;
    my $buffer = $ui->get_object('text')->get_buffer();
    return 0 unless $buffer->get_has_selection();
    my ($start, $end) = $buffer->get_selection_bounds();
    my $text = $buffer->get_text($start, $end, 1);
    $buffer->delete($start, $end);
    my $parms = join(" ", @_);
    $parms = " $parms" if $parms;
    report 'Set ', $attr, $parms;
    $buffer->insert($start, "<$attr$parms>$text</$attr>");
    current_label()->from_ui() if current_label();
    update_previews();
}

sub underline_clicked_cb   { attribute_clicked('u');   }
sub tt_clicked_cb          { attribute_clicked('tt'); }
sub italic_clicked_cb      { attribute_clicked('i');   }
sub bold_clicked_cb        { attribute_clicked('b');   }
sub sub_clicked_cb         { attribute_clicked('sub'); }
sub sup_clicked_cb         { attribute_clicked('sup'); }

sub tape_changed_cb { update_previews(); }

sub font_set_cb {
    my $font = $ui->get_object('font')->get_font_name();
    unless (attribute_clicked("span", "font=\"$font\"")) {
        # If there is no currently selected text, set the default
        report 'Set default font ', $ui->get_object('font')->get_font_name();
        $default_fontdesc = Pango::FontDescription->from_string(
            $ui->get_object('font')->get_font_name());
    }
    update_previews();
}

sub ui_changed {
    current_label()->from_ui() if current_label();
    update_previews();
}

sub current_label {
    if (scalar(@_)) {
        $current_label = shift;
        print STDERR "Set label $current_label\n";
        if ($current_label >= 0 && $labels[$current_label]) {
            $labels[$current_label]->to_ui();
            foreach my $k (@$PER_LABEL) {
                $ui->get_object($k)->set_sensitive(1);
            }
            $ui->get_object('label_index')->set_text($current_label);
            $ui->get_object('text')->grab_focus();
        } else {
            foreach my $k (@$PER_LABEL) {
                $ui->get_object($k)->set_sensitive(0);
            }
            $ui->get_object('label_index')->set_text('');
            $ui->get_object('text')->get_buffer()->set_text('');
        }
        update_previews();
    }
    if ($current_label >= 0 && $current_label < scalar(@labels)) {
        return $labels[$current_label];
    }
    return undef;
}

sub add_label_clicked_cb {
    my $label = new Label();
    push(@labels, $label);
    current_label(scalar(@labels) - 1);
}

sub delete_label_clicked_cb {
    return unless current_label();
    report 'Delete label ', $current_label;
    splice(@labels, $current_label, 1);
    if ($current_label == scalar(@labels)) {
        $current_label--;
        current_label($current_label);
    } elsif ($current_label >= 0) {
        current_label($current_label);
    } else {
        current_label(-1);
    }
    report 'New label ', current_label;
}

sub mouse_down_cb {
    my ($scroll, $event) = @_;
    # the x,y are relative to the viewport
    my $x = $event->x() + $scroll->get_hadjustment()->get_value();
    my $im = $ui->get_object("all_image");
    my $ipb = $im->get_pixbuf();
    my $all = $im->get_allocation();
    if ($ipb->get_width() < $all->width()) {
        $x -= ($all->width() - $ipb->get_width()) / 2;
    }
    #print STDERR "Mouse at $x\n";
    current_label(label_at($x));
}

sub text_insert_at_cursor { update_previews(); }

# Reacts to most GUI changes, updates the preview to match the changes.
sub update_previews {
    # Enable the print button if we have some labels
    $ui->get_object('print')->set_sensitive(scalar(@labels));
    my $pb = render_labels(1);
    if ($pb) {
        $ui->get_object('print')->set_sensitive(1);
        $ui->get_object('all_image')->set_from_pixbuf($pb);
    } else {
        $ui->get_object('print')->set_sensitive(1);
        $ui->get_object('all_image')->clear();
    }
    my $cl = current_label();
    my $size = '';
    if ($cl && $cl->{surface}) {
        my $lpb = Gtk2::Gdk::Pixbuf->new_from_data(
            $cl->{surface}->get_data(),
            'rgb', 1, 8,
            $cl->{surface}->get_width(),
            $cl->{surface}->get_height(),
            $cl->{surface}->get_stride());
        
        $ui->get_object('current_image')->set_from_pixbuf($lpb);
        $size = $cl->{pxwidth} . 'px ' . $cl->{mmwidth} . "mm";
    } else {
        $ui->get_object('current_image')->clear();
    }
    $ui->get_object('label_size')->set_text($size);

}

sub encode {
    $_[0] = '' unless defined $_[0];
    $_[0] =~ s/\\/\\\\/g;
    $_[0] =~ s/\n/\\n/g;
    return $_[0];
}

sub decode {
    $_[0] = '' unless defined $_[0];
    $_[0] =~ s/\\n/\n/g;
    $_[0] =~ s/\\\\/\\/g;
    return $_[0];
}

sub save_config {
    my $f;
    report 'Saving to ', SETTINGS;

    open($f, '>:encoding(utf8)', SETTINGS) || die $!;
    foreach my $opt (@$BASE) {
        my $spec = $CONFIG->{$opt};
        next if $opt eq 'default';
        my $save = ($spec && $spec->{save}) || $CONFIG->{default}->{save};
        print $f "$opt=" . encode(&$save($ui->get_object($opt))) . "\n";
    }
    for (my $i = 0; $i < scalar(@labels); $i++) {
        my $label = $labels[$i];
        foreach my $k ( @$PER_LABEL ) {
            if (defined $label->{$k}) {
                print $f "label$i$k=".encode($label->{$k})."\n";
            }
        }
    }
    print $f "current_label=$current_label\n" if
        ($current_label >= 0 && $current_label < scalar(@labels));
    close($f);
}

sub load_config {
    $ui->get_object('halign')->set_active(0);
    $ui->get_object('tape')->set_active(0);
    $ui->get_object('printer')->set_active(0);
    return unless -e SETTINGS;
    open(my $f, '<:encoding(utf8)', SETTINGS) || die $!;
    local $/ = "\n";
    foreach my $setting (<$f>) {
        chomp($setting);
        next unless $setting;
        my ($k, $v) = split("=", $setting, 2);
        $v = decode($v);
        #print STDERR "Load '$k' = '$v'\n";
        if ($k =~ /^label(\d+)(.*?)$/) {
            my ($n, $k) = ($1, $2);
            unless ($labels[$n]) {
                $labels[$n] = new Label();
                #print STDERR "Made label $n\n";
            }
            $labels[$n]->{$k} = $v;
            #print STDERR "Label[$n]->{$k}=".$labels[$n]->{$k}."\n";
        } elsif ($k eq 'current_label') {
            current_label($v);
        } else {
            my $spec = $CONFIG->{$k};
            my $load = ($spec && $spec->{load}) || $CONFIG->{default}->{load};
            &$load($ui->get_object($k), $v);
        }
    }
    close($f);

    $default_fontdesc = Pango::FontDescription->from_string(
        $ui->get_object('font')->get_font_name());
    report $default_fontdesc, $default_fontdesc->get_size();
}

sub init_ui {
    $ui = Gtk2::Builder->new();
    $ui->add_from_file(GLADE_FILE);
    $ui->connect_signals();

    fill_printer_list();

    load_config();

    $ui->get_object('text')->get_buffer()->signal_connect('changed', \&ui_changed);
    update_previews();
}

binmode(STDIN,  ":utf8");
binmode(STDOUT, ":utf8");
binmode(STDERR, ":utf8");

($device) = @ARGV;

init_ui();
Gtk2->main();
